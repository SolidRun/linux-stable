// SPDX-License-Identifier: (GPL-2.0 OR MIT)
//
// Device Tree file for SolidSense N8 Compact
//
// Copyright 2024 Josua Mayer <josua@solid-run.com>

/dts-v1/;

#include <dt-bindings/leds/common.h>

#include "imx8mn.dtsi"

/ {
	model = "SolidRun SolidSense N8 Compact";
	compatible = "solidrun,solidsense-n8-compact", "fsl,imx8mn";

	aliases {
		gpio5 = &expander;
		rtc0 = &rtc;
		rtc1 = &snvs_rtc;
		usb0 = &usbotg1;
		watchdog0 = &wdog1;
		watchdog1 = &rtc;
	};

	chosen {
		stdout-path = &uart2;
	};

	/*poll IO Expander and reboot in case of power loss*/
	gpio-keys {
		compatible = "gpio-keys";
		autorepeat;

		key-power-fail {
			label = "Power Fail";
			linux,code = <KEY_RESTART>;
			gpios = <&expander 1 GPIO_ACTIVE_LOW>;
			debounce-interval = <100>;
			linux,can-disable;
		};
	};

	/* LED labels based on enclosure, schematic names differ. */
	leds {
		compatible = "gpio-leds";
		pinctrl-names = "default";
		pinctrl-0 = <&led_pins>;

		/* D20 */
		led1 {
			lable = "led1";
		        gpios = <&gpio1 13 GPIO_ACTIVE_HIGH>;
		        default-state = "off";
		};

		/* D18 */
		led2 {
			lable = "led2";
		        gpios = <&gpio1 11 GPIO_ACTIVE_HIGH>;
		        default-state = "off";
		};

		/* D19 */
		led3 {
			lable = "led3";
		        gpios = <&gpio1 12 GPIO_ACTIVE_HIGH>;
		        default-state = "off";
		};
	};

	reg_modem_vbat: regulator-modem-vbat {
		compatible = "regulator-fixed";
		regulator-name = "modem-vbat";
		pinctrl-names = "default";
		pinctrl-0 = <&regulator_modem_vbat_pins>;
		regulator-min-microvolt = <3800000>;
		regulator-max-microvolt = <3800000>;
		gpio = <&gpio3 25 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		regulator-always-on;
	};

	/* power to lte modems behind hub ports 2/3 */
	reg_modem_vbus: regulator-modem-vbus {
		compatible = "regulator-fixed";
		regulator-name = "modem-vbus";
		pinctrl-names = "default";
		pinctrl-0 = <&regulator_modem_vbus_pins>;
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		gpio = <&gpio5 4 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		regulator-always-on;
	};

	/* power to usb hub, and type-a behind hub port 1 */
	reg_usb1_vbus: regulator-usb1-vbus {
		compatible = "regulator-fixed";
		regulator-name = "usb1-vbus";
		pinctrl-names = "default";
		pinctrl-0 = <&regulator_usb1_vbus_pins>;
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		gpio = <&gpio5 5 GPIO_ACTIVE_HIGH>;
		enable-active-high;
	};

	reg_vdd_1v8: regulator-vdd-1v8 {
		compatible = "regulator-fixed";
		regulator-name = "vdd-1v8";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
	};

	reg_vdd_3v3: regulator-vdd-3v3 {
		compatible = "regulator-fixed";
		regulator-name = "vdd-3v3";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
	};

	reg_usdhc2_vmmc: regulator-usdhc2-vmmc {
		compatible = "regulator-fixed";
		regulator-name = "usdhc2-vmmc";
		pinctrl-names = "default";
		pinctrl-0 = <&regulator_usdhc2_vmmc_pins>;
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		vin-supply = <&reg_vdd_3v3>;
		gpio = <&gpio2 19 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		off-on-delay-us = <250>;
	};

	rfkill {
		compatible = "rfkill-gpio";
		label = "rfkill-wwan";
		radio-type = "wwan";
		pinctrl-names = "default";
		pinctrl-0 = <&modem_pins>;
		reset-gpios = <&gpio1 7 GPIO_ACTIVE_HIGH>;
	};

	usdhc1_pwrseq: usdhc1-pwrseq {
		compatible = "mmc-pwrseq-simple";
		reset-gpios = <&gpio2 10 GPIO_ACTIVE_LOW>;
	};
};

&ecspi2 {
	pinctrl-names = "default";
	pinctrl-0 = <&ecspi2_pins>;
	/* native chip-select causes reading 0xffffffff */
	cs-gpios = <&gpio5 13 GPIO_ACTIVE_LOW>;
	num-cs = <1>;
	status = "okay";

	can@0 {
		compatible = "microchip,mcp2518fd";
		reg = <0>;
		spi-max-frequency = <20000000>;
		pinctrl-names = "default";
		pinctrl-0 = <&can_pins>;
		interrupt-parent = <&gpio5>;
		interrupts = <1 IRQ_TYPE_EDGE_FALLING>;
		clocks = <&clk IMX8MN_CLK_CLKOUT1>;
		/* generate 8MHz clock from soc-internal 24mhz reference */
		assigned-clocks = <&clk IMX8MN_CLK_CLKOUT1_SEL>,
			  <&clk IMX8MN_CLK_CLKOUT1_DIV>;
		assigned-clock-rates = <0>, <8000000>;
		assigned-clock-parents = <&clk IMX8MN_CLK_24M>, <0>;
	};
};

&fec1 {
	pinctrl-names = "default";
	pinctrl-0 = <&fec1_pins>;
	phy-mode = "rgmii-id";
	phy-handle = <&phy4>;
	local-mac-address = [00 00 00 00 00 00];
	fsl,magic-packet;
	status = "okay";

	mdio {
		#address-cells = <1>;
		#size-cells = <0>;

		/*
		 * Depending on board revision two different phys are used:
		 * - v1.1: atheros phy at address 4
		 * - v1.2+: analog devices phy at address 0
		 * Configure first version by default.
		 * On v1.2 and later, U-Boot will enable the correct phy
		 * based on runtime detection and patch dtb accordingly.
		 */

		/* ADIN1300 */
		phy0: ethernet-phy@0 {
			reg = <0>;
			reset-gpios = <&gpio3 19 GPIO_ACTIVE_LOW>;
			reset-assert-us = <10>;
			reset-deassert-us = <5000>;
			interrupt-parent = <&gpio1>;
			interrupts = <10 IRQ_TYPE_LEVEL_LOW>;
			adi,link-st-polarity = <GPIO_ACTIVE_LOW>;
			adi,led-polarity = <GPIO_ACTIVE_LOW>;
			status = "disabled";

			leds {
				#address-cells = <1>;
				#size-cells = <0>;

				led@0 {
					reg = <0>;
					color = <LED_COLOR_ID_YELLOW>;
					function = LED_FUNCTION_LAN;
					default-state = "keep";
					active-low;
				};
			};
		};

		/* AR8035 */
		phy4: ethernet-phy@4 {
			reg = <4>;
			reset-gpios = <&gpio3 19 GPIO_ACTIVE_LOW>;
			reset-assert-us = <10000>;
			status = "okay";
		};
	};
};

&gpio5 {
	usb-hub-reset-hog {
		gpio-hog;
		gpios = <3 GPIO_ACTIVE_LOW>;
		output-low; /* deasserted */
		line-name = "usb-hub-reset";
	};
};

&i2c1 {
	pinctrl-names = "default";
	pinctrl-0 = <&i2c1_pins>;
	status = "okay";

	pmic@4b {
		compatible = "rohm,bd71847";
		reg = <0x4b>;
		pinctrl-names = "default";
		pinctrl-0 = <&pmic_pins>;
		interrupt-parent = <&gpio1>;
		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
		rohm,reset-snvs-powered;

		#clock-cells = <0>;
		clocks = <&osc_32k>;
		clock-output-names = "clk-32k-out";

		regulators {
			BUCK1 {
				// supplies soc vdd, soc mipi vdd @ 0.9V
				regulator-name = "buck1";
				regulator-min-microvolt = <700000>;
				regulator-max-microvolt = <1300000>;
				regulator-boot-on;
				regulator-always-on;
				regulator-ramp-delay = <1250>;
				rohm,dvs-run-voltage = <850000>;
				rohm,dvs-suspend-voltage = <750000>;
			};

			BUCK2 {
				regulator-name = "buck2";
				regulator-min-microvolt = <700000>;
				regulator-max-microvolt = <1300000>;
				regulator-boot-on;
				regulator-always-on;
				regulator-ramp-delay = <1250>;
				rohm,dvs-run-voltage = <1000000>;
				rohm,dvs-idle-voltage = <900000>;
				rohm,dvs-suspend-voltage = <0>;
			};

			BUCK3 {
				// BUCK5 in datasheet
				// output floating
				regulator-name = "buck3";
				regulator-min-microvolt = <700000>;
				regulator-max-microvolt = <1350000>;
			};

			BUCK4 {
				// BUCK6 in datasheet
				// supplies ldo3, ldo5, muxsw
				regulator-name = "buck4";
				regulator-min-microvolt = <3000000>;
				regulator-max-microvolt = <3300000>;
				regulator-boot-on;
				regulator-always-on;
			};

			BUCK5 {
				// BUCK7 in datasheet
				// supplies ldo4, ldo6, muxsw
				// enables dram vpp @ 2.5V
				regulator-name = "buck5";
				regulator-min-microvolt = <1605000>;
				regulator-max-microvolt = <1995000>;
				regulator-boot-on;
				regulator-always-on;
			};

			BUCK6 {
				// BUCK8 in datasheet
				// supplies dram @ 1.2V
				regulator-name = "buck6";
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <1400000>;
				regulator-boot-on;
				regulator-always-on;
			};

			LDO1 {
				// supplies soc snvs @ 1.8V
				regulator-name = "ldo1";
				regulator-min-microvolt = <1600000>;
				regulator-max-microvolt = <3300000>;
				regulator-boot-on;
				regulator-always-on;
			};

			LDO2 {
				// supplies soc snvs @ 0.8V
				regulator-name = "ldo2";
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <900000>;
				regulator-boot-on;
				regulator-always-on;
			};

			LDO3 {
				// supplies soc vdd @ 1.8V
				regulator-name = "ldo3";
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3300000>;
				regulator-boot-on;
				regulator-always-on;
			};

			LDO4 {
				// output floating
				regulator-name = "ldo4";
				regulator-min-microvolt = <900000>;
				regulator-max-microvolt = <1800000>;
			};

			LDO5 {
				// output floating
				regulator-name = "ldo5";
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <3300000>;
			};

			LDO6 {
				// supplies soc vdd mipi @ 1.2V
				regulator-name = "ldo6";
				regulator-min-microvolt = <900000>;
				regulator-max-microvolt = <1800000>;
				regulator-boot-on;
				regulator-always-on;
			};
		};
	};
};

&i2c2 {
	/*
	 * routed to various connectors:
	 * - basler camera (CON2)
	 * - touchscreen (J3)
	 * - expansion connector (J14)
	 */
	pinctrl-names = "default";
	pinctrl-0 = <&i2c2_pins>;
	status = "okay";
};

&i2c3 {
	pinctrl-names = "default";
	pinctrl-0 = <&i2c3_pins>;
	status = "okay";

	expander: gpio@20 {
		compatible = "ti,tca6408";
		reg = <0x20>;
		pinctrl-names = "default";
		pinctrl-0 = <&gpio_expander_pins>;
		reset-gpios = <&gpio3 16 GPIO_ACTIVE_LOW>;
		interrupt-parent = <&gpio2>;
		interrupts = <11 IRQ_TYPE_EDGE_FALLING>;
		interrupt-controller;
		#interrupt-cells = <2>;
		gpio-controller;
		#gpio-cells = <2>;
		gpio-line-names = "SYSGD", "PFO#", "CAPGD", "CAPFLT#",
				  "CHGEN#", "BSTEN#", "", "";
	};

	light-sensor@44 {
		compatible = "isil,isl29023";
		reg = <0x44>;
	};

	accelerometer@53 {
		compatible = "adi,adxl345";
		reg = <0x53>;
	};

	/* battery-charger@68 */

	rtc: rtc@69 {
		compatible = "abracon,abx80x";
		reg = <0x69>;
		pinctrl-names = "default";
		pinctrl-0 = <&rtc_pins>;
		abracon,tc-diode = "schottky";
		abracon,tc-resistor = <3>;
		interrupt-parent = <&gpio1>;
		interrupts = <1 IRQ_TYPE_EDGE_FALLING>;
	};
};

&i2c4 {
	/* routed to expansion connector (J14) */
	pinctrl-names = "default";
	pinctrl-0 = <&i2c4_pins>;
	status = "okay";
};

&iomuxc {
	pinctr-names = "default";
	pinctrl-0 = <&tamper_pins>, <&usb_hub_pins>;

	ieee802151_radio_pins: ieee802151-radio-pins {
		fsl,pins = <
			/* RESETN */
			MX8MN_IOMUXC_GPIO1_IO05_GPIO1_IO5	0x0 /* TODO: pull / set 1? */
			/* VDD_EN */
			MX8MN_IOMUXC_GPIO1_IO06_GPIO1_IO6	0x0
			/* SWDCLK */
			MX8MN_IOMUXC_GPIO1_IO14_GPIO1_IO14	0x0 /* TODO: pull-up? */
			/* SDIO */
			MX8MN_IOMUXC_GPIO1_IO15_GPIO1_IO15	0x0 /* TODO: pull-up? */
		>;
	};

	can_pins: can-pins {
		fsl,pins = <
			MX8MN_IOMUXC_SAI3_TXD_GPIO5_IO1		0x140
		>;
	};

	ecspi2_pins: ecspi2-pins {
		fsl,pins = <
			MX8MN_IOMUXC_ECSPI2_SCLK_ECSPI2_SCLK	0x96
			MX8MN_IOMUXC_ECSPI2_MOSI_ECSPI2_MOSI	0x1d6
			MX8MN_IOMUXC_ECSPI2_MISO_ECSPI2_MISO	0x1d6
			MX8MN_IOMUXC_ECSPI2_SS0_GPIO5_IO13	0x1d6
		>;
	};

	fec1_pins: fec1-pins {
		/*
		 * Some pins are sampled at phy reset to apply configuration:
		 * - AR803x PHY (revision 1.1)
		 *   - RXD[1:0]: phy address bits [1:0]
		 *   - RXD[3:2],RX_CTL: mac interface select bits 3,1,0
		 * - ADIN1300 PHY (revision 1.2 or later)
		 *   - RXD[3:0]: phy address bits [3:0]
		 *   - RX_CTL,RXC: mac interface select bits 1,0
		 * SoC enables pull-down at reset, PHYs have internal
		 * pull-down, so pinmux may unset pull-enable.
		 */
		fsl,pins = <
			MX8MN_IOMUXC_ENET_MDC_ENET1_MDC			0x2
			MX8MN_IOMUXC_ENET_MDIO_ENET1_MDIO		0x2
			MX8MN_IOMUXC_ENET_TD3_ENET1_RGMII_TD3		0x1e
			MX8MN_IOMUXC_ENET_TD2_ENET1_RGMII_TD2		0x1e
			MX8MN_IOMUXC_ENET_TD1_ENET1_RGMII_TD1		0x1e
			MX8MN_IOMUXC_ENET_TD0_ENET1_RGMII_TD0		0x1e
			/* RD[3:0] sampled at phy reset for address bits [3:0] */
			MX8MN_IOMUXC_ENET_RD3_ENET1_RGMII_RD3		0x90
			MX8MN_IOMUXC_ENET_RD2_ENET1_RGMII_RD2		0x90
			MX8MN_IOMUXC_ENET_RD1_ENET1_RGMII_RD1		0x90
			MX8MN_IOMUXC_ENET_RD0_ENET1_RGMII_RD0		0x90
			MX8MN_IOMUXC_ENET_TXC_ENET1_RGMII_TXC		0x10
			MX8MN_IOMUXC_ENET_RXC_ENET1_RGMII_RXC		0x90
			MX8MN_IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL	0x90
			MX8MN_IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL	0x10
			/* phy reset */
			MX8MN_IOMUXC_SAI5_RXFS_GPIO3_IO19		0x0
			/* phy interrupt */
			MX8MN_IOMUXC_GPIO1_IO10_GPIO1_IO10		0x140
		>;
	};

	gpio_expander_pins: gpio-expander-pins {
		fsl,pins = <
			MX8MN_IOMUXC_NAND_READY_B_GPIO3_IO16	0x140
			MX8MN_IOMUXC_SD1_STROBE_GPIO2_IO11	0x140
		>;
	};

	i2c1_pins: i2c1-pins {
		fsl,pins = <
			MX8MN_IOMUXC_I2C1_SCL_I2C1_SCL		0x400001c2
			MX8MN_IOMUXC_I2C1_SDA_I2C1_SDA		0x400001c2
		>;
	};

	i2c2_pins: i2c2-pins {
		fsl,pins = <
			MX8MN_IOMUXC_I2C2_SCL_I2C2_SCL		0x400001c2
			MX8MN_IOMUXC_I2C2_SDA_I2C2_SDA		0x400001c2
		>;
	};

	i2c3_pins: i2c3-pins {
		fsl,pins = <
			MX8MN_IOMUXC_I2C3_SCL_I2C3_SCL		0x400001c2
			MX8MN_IOMUXC_I2C3_SDA_I2C3_SDA		0x400001c2
		>;
	};

	i2c4_pins: i2c4-pins {
		fsl,pins = <
			MX8MN_IOMUXC_I2C4_SCL_I2C4_SCL		0x400001c2
			MX8MN_IOMUXC_I2C4_SDA_I2C4_SDA		0x400001c2
		>;
	};

	led_pins: led-pins {
		fsl,pins = <
			MX8MN_IOMUXC_GPIO1_IO11_GPIO1_IO11	0x100
			MX8MN_IOMUXC_GPIO1_IO12_GPIO1_IO12	0x100
			MX8MN_IOMUXC_GPIO1_IO13_GPIO1_IO13	0x100
		>;
	};

	modem_pins: modem-pins {
		fsl,pins = <
			/* RESET_N: modem-internal pull-down */
			MX8MN_IOMUXC_GPIO1_IO07_GPIO1_IO7	0x0
			/* PWRKEY: pull-down ensures always-on */
			MX8MN_IOMUXC_GPIO1_IO08_GPIO1_IO8	0x100
		>;
	};

	pmic_pins: pmic-pins {
		fsl,pins = <
			MX8MN_IOMUXC_GPIO1_IO03_GPIO1_IO3	0x140
		>;
	};

	regulator_modem_vbat_pins: regulator-modem-vbat-pins {
		fsl,pins = <
			MX8MN_IOMUXC_SAI5_MCLK_GPIO3_IO25	0x0
		>;
	};

	regulator_modem_vbus_pins: regulator-modem-vbus-pins {
		fsl,pins = <
			MX8MN_IOMUXC_SPDIF_RX_GPIO5_IO4		0x0
		>;
	};

	regulator_usb1_vbus_pins: regulator-usb1-vbus-pins {
		fsl,pins = <
			MX8MN_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5	0x0
		>;
	};

	regulator_usdhc2_vmmc_pins: regulator-usdhc2-vmmc-pins {
		fsl,pins = <
			MX8MN_IOMUXC_SD2_RESET_B_GPIO2_IO19	0x0
		>;
	};

	rtc_pins: rtc-pins {
		fsl,pins = <
			MX8MN_IOMUXC_GPIO1_IO01_GPIO1_IO1	0x140
			MX8MN_IOMUXC_SAI3_RXFS_GPIO4_IO28	0x100
		>;
	};

	tamper_pins: tamper-pins {
		/*
		 * Routed to physical tamper input (J12),
		 * accelerometer and light-sensor interrupts.
		 */
		fsl,pins = <
			MX8MN_IOMUXC_GPIO1_IO09_GPIO1_IO9	0x140
		>;
	};

	uart1_pins: uart1-pins {
		fsl,pins = <
			MX8MN_IOMUXC_UART1_RXD_UART1_DCE_RX	0x140
			MX8MN_IOMUXC_UART1_TXD_UART1_DCE_TX	0x140
			MX8MN_IOMUXC_UART3_RXD_UART1_DCE_CTS_B	0x140
			MX8MN_IOMUXC_UART3_TXD_UART1_DCE_RTS_B	0x140
			/* BT_REG_ON */
			MX8MN_IOMUXC_SD1_DATA4_GPIO2_IO6	0x0
			/* BT_WAKE_DEV */
			MX8MN_IOMUXC_SD1_DATA5_GPIO2_IO7	0x0
			/* BT_WAKE_HOST */
			MX8MN_IOMUXC_SD1_DATA6_GPIO2_IO8	0x100
		>;
	};

	uart2_pins: uart2-pins {
		fsl,pins = <
			MX8MN_IOMUXC_UART2_RXD_UART2_DCE_RX	0x140
			MX8MN_IOMUXC_UART2_TXD_UART2_DCE_TX	0x140
		>;
	};

	uart3_pins: uart3-pins {
		fsl,pins = <
			MX8MN_IOMUXC_ECSPI1_MOSI_UART3_DTE_RX	0x140
			MX8MN_IOMUXC_ECSPI1_SCLK_UART3_DTE_TX	0x140
			MX8MN_IOMUXC_ECSPI1_MISO_UART3_DTE_RTS_B	0x140
			MX8MN_IOMUXC_ECSPI1_SS0_UART3_DTE_CTS_B	0x140
		>;
	};

	uart4_pins: uart4-pins {
		fsl,pins = <
			MX8MN_IOMUXC_UART4_RXD_UART4_DCE_RX	0x140
			MX8MN_IOMUXC_UART4_TXD_UART4_DCE_TX	0x140
		>;
	};

	usb_hub_pins: usb-hub-pins {
		fsl,pins = <
			MX8MN_IOMUXC_SPDIF_TX_GPIO5_IO3		0x0
		>;
	};

	usdhc1_pins: usdhc1-pins {
		fsl,pins = <
			MX8MN_IOMUXC_SD1_CLK_USDHC1_CLK		0x190
			MX8MN_IOMUXC_SD1_CMD_USDHC1_CMD		0x1d0
			MX8MN_IOMUXC_SD1_DATA0_USDHC1_DATA0	0x1d0
			MX8MN_IOMUXC_SD1_DATA1_USDHC1_DATA1	0x1d0
			MX8MN_IOMUXC_SD1_DATA2_USDHC1_DATA2	0x1d0
			MX8MN_IOMUXC_SD1_DATA3_USDHC1_DATA3	0x1d0
			/* wifi refclk */
			MX8MN_IOMUXC_GPIO1_IO00_ANAMIX_REF_CLK_32K	0x0
			/* WL_WAKE_HOST */
			MX8MN_IOMUXC_SD1_DATA7_GPIO2_IO9	0x100
			/* WL_REG_ON */
			MX8MN_IOMUXC_SD1_RESET_B_GPIO2_IO10	0x0
		>;
	};

	usdhc2_pins: usdhc2-pins {
		fsl,pins = <
			MX8MN_IOMUXC_SD2_CLK_USDHC2_CLK		0x190
			MX8MN_IOMUXC_SD2_CMD_USDHC2_CMD		0x1d0
			MX8MN_IOMUXC_SD2_DATA0_USDHC2_DATA0	0x1d0
			MX8MN_IOMUXC_SD2_DATA1_USDHC2_DATA1	0x1d0
			MX8MN_IOMUXC_SD2_DATA2_USDHC2_DATA2	0x1d0
			MX8MN_IOMUXC_SD2_DATA3_USDHC2_DATA3	0x1d0
			MX8MN_IOMUXC_SD2_CD_B_USDHC2_CD_B	0x0
			/* usdhc2 signalling voltage pmic control */
			MX8MN_IOMUXC_GPIO1_IO04_USDHC2_VSELECT	0x140
		>;
	};

	usdhc2_100mhz_pins: usdhc2-100mhz-pins {
		fsl,pins = <
			MX8MN_IOMUXC_SD2_CLK_USDHC2_CLK		0x194
			MX8MN_IOMUXC_SD2_CMD_USDHC2_CMD		0x1d4
			MX8MN_IOMUXC_SD2_DATA0_USDHC2_DATA0	0x1d4
			MX8MN_IOMUXC_SD2_DATA1_USDHC2_DATA1	0x1d4
			MX8MN_IOMUXC_SD2_DATA2_USDHC2_DATA2	0x1d4
			MX8MN_IOMUXC_SD2_DATA3_USDHC2_DATA3	0x1d4
			MX8MN_IOMUXC_SD2_CD_B_USDHC2_CD_B	0x0
			/* usdhc2 signalling voltage pmic control */
			MX8MN_IOMUXC_GPIO1_IO04_USDHC2_VSELECT	0x140
		>;
	};

	usdhc2_200mhz_pins: usdhc2-100mhz-pins {
		fsl,pins = <
			MX8MN_IOMUXC_SD2_CLK_USDHC2_CLK		0x196
			MX8MN_IOMUXC_SD2_CMD_USDHC2_CMD		0x1d6
			MX8MN_IOMUXC_SD2_DATA0_USDHC2_DATA0	0x1d6
			MX8MN_IOMUXC_SD2_DATA1_USDHC2_DATA1	0x1d6
			MX8MN_IOMUXC_SD2_DATA2_USDHC2_DATA2	0x1d6
			MX8MN_IOMUXC_SD2_DATA3_USDHC2_DATA3	0x1d6
			MX8MN_IOMUXC_SD2_CD_B_USDHC2_CD_B	0x0
			/* usdhc2 signalling voltage pmic control */
			MX8MN_IOMUXC_GPIO1_IO04_USDHC2_VSELECT	0x140
		>;
	};

	usdhc3_pins: usdhc3-pins {
		fsl,pins = <
			MX8MN_IOMUXC_NAND_WE_B_USDHC3_CLK	0x190
			MX8MN_IOMUXC_NAND_WP_B_USDHC3_CMD	0x1d0
			MX8MN_IOMUXC_NAND_DATA04_USDHC3_DATA0	0x1d0
			MX8MN_IOMUXC_NAND_DATA05_USDHC3_DATA1	0x1d0
			MX8MN_IOMUXC_NAND_DATA06_USDHC3_DATA2	0x1d0
			MX8MN_IOMUXC_NAND_DATA07_USDHC3_DATA3	0x1d0
			MX8MN_IOMUXC_NAND_RE_B_USDHC3_DATA4	0x1d0
			MX8MN_IOMUXC_NAND_CE2_B_USDHC3_DATA5	0x1d0
			MX8MN_IOMUXC_NAND_CE3_B_USDHC3_DATA6	0x1d0
			MX8MN_IOMUXC_NAND_CLE_USDHC3_DATA7	0x1d0
			MX8MN_IOMUXC_NAND_CE1_B_USDHC3_STROBE	0x190
		>;
	};

	wdog1_pins: wdog1-pins {
		fsl,pins = <
			MX8MN_IOMUXC_GPIO1_IO02_WDOG1_WDOG_B	0x140
		>;
	};
};

/* Bluetooth */
&uart1 {
	pinctrl-names = "default";
	pinctrl-0 = <&uart1_pins>;
	uart-has-rtscts;
	status = "okay";

	bluetooth {
		compatible = "brcm,bcm4330-bt";
		device-wakeup-gpios = <&gpio2 7 GPIO_ACTIVE_HIGH>;
		host-wakeup-gpios = <&gpio2 8 GPIO_ACTIVE_HIGH>;
		shutdown-gpios = <&gpio2 6 GPIO_ACTIVE_HIGH>;
		max-speed = <1500000>;
	};
};

/* console */
&uart2 {
	pinctrl-names = "default";
	pinctrl-0 = <&uart2_pins>;
	status = "okay";
};

/* RS485 */
&uart3 {
	pinctrl-names = "default";
	pinctrl-0 = <&uart3_pins>;
	uart-has-rtscts;
	linux,rs485-enabled-at-boot-time;
	fsl,dte-mode;
	status = "okay";
};

/* 802.15.1 radio */
&uart4 {
	pinctrl-names = "default";
	pinctrl-0 = <&uart4_pins &ieee802151_radio_pins>;
	status = "okay";
};

&usbotg1 {
	vbus-supply = <&reg_usb1_vbus>;
	dr_mode = "host";
	disable-over-current;
	status  = "okay";
};

/* WiFi */
&usdhc1 {
	pinctrl-names = "default";
	pinctrl-0 = <&usdhc1_pins>;
	vmmc-supply = <&reg_vdd_3v3>;
	vqmmc-supply = <&reg_vdd_1v8>;
	bus-width = <4>;
	mmc-pwrseq = <&usdhc1_pwrseq>;
	status = "okay";
};

/* microSD */
&usdhc2 {
	pinctrl-names = "default", "state_100mhz", "state_200mhz";
	pinctrl-0 = <&usdhc2_pins>;
	pinctrl-1 = <&usdhc2_100mhz_pins>;
	pinctrl-2 = <&usdhc2_200mhz_pins>;
	vmmc-supply = <&reg_usdhc2_vmmc>;
	bus-width = <4>;
	broken-cd;
	status = "okay";
};

/* eMMC */
&usdhc3 {
	/*
	 * Use lowest drive strength for all high-speed modes to minimise
	 * electro-magnetic emissions.
	 * In this particular design HS-400 still works okay, no extra
	 * pinctrl for 100mhz and 200mhz are required.
	 */
	pinctrl-names = "default";
	pinctrl-0 = <&usdhc3_pins>;
	vmmc-supply = <&reg_vdd_3v3>;
	vqmmc-supply = <&reg_vdd_1v8>;
	bus-width = <8>;
	non-removable;
	status = "okay";
};

&wdog1 {
	pinctrl-names = "default";
	pinctrl-0 = <&wdog1_pins>;
	status = "okay";
};
